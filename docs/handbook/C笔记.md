# 逆向

## include

(在c语言中，需要注意的是头文件的包含方式，)

``#include <stdio.h> ``   ``#include "stdio.h" `` 这两种是不一样的，用``<>``包含的头文件，系统只会在环境变量中搜索头文件库。如果是使用``" "``包含的头文件，系统只会先在当前目录里搜素，要是没找到才会去环境变量里找。

## int main 
* 是用户入口，用户从main函数开始有控制权，在mian函数开始可以接管程序的流程，也就是说main函数的返回值就是进程的返回值
* 先获得操作系统版本
* 初始化堆环境
* 初始化多线程环境
* 初始化ioi对象
* 获取命令行
* 获取环境变量
* 格式化命令行
* 初始化全局变量
* 初始化获得程序进程的基本信息
* 最后再找到main函数
* 运行代码
* 释放全局对象


**1：printf有三个变量分别是：**
* 功能stdout(格式化输出到标准输出设备，默认是显示器也可以说是屏幕)
* stdin(标准输入对象，默认是键盘)
* stderr(标准错误对象，默认是显示器，屏幕)

**2.printf也存在返回值，例如：**
```C
// --run--
int a = printf("Hello world\r\n");

printf("%d\r\n", a);
```
>运行结果是：`Hello world`, `14`

# 变量命名规范
```C
例如：
int nStudentCount = 0;

float fStudentCount = 0.0f;

double dblStudentCount = 0.0;

char cStudengCount = '\0';

short int snStudengCount = 0;

int *pnStudengCount = NULL;
```



### * scanf从标准输入设备格式化到指定的内存地址上

* ``scanf(%d, &n)`` ,%d意思是存入的字符是整形(int),&n是取变量n的地址

* 假设我设置一个变量的值为999，则它对应的16进制是3e7。而它在系统中储存的方式是E7 03 00 00。读法是从右往左读，但每两个相邻的数字却是从左往右读。

![Img](https://rtyu-1317440738.cos.ap-guangzhou.myqcloud.com/202305091942351.webp)


* 从标准输入设备格式化输入到指定内存地址上的数据存放方式有：
1.小尾方式：低数据位存放在低地址处，高数据位存放在高地址处
2.大尾方式：高数据为存放在低地址处，高数据存放在高地址处。其实两个都差不多意思

![Img](https://rtyu-1317440738.cos.ap-guangzhou.myqcloud.com/202305091943293.webp)


* 还有在设置变量的时候一定要初始化，给出相对应的初始值，防止一些奇奇怪怪的问题



## scan输入类型问题
* 这一串代码输入1和2回车后会覆盖初始值
```c
// --run--
short int ary[2] = {0};

printf("%08x\r\n", ary);
system("pause");

scanf("%d", &ary[0]);
scanf("%d", &ary[1]);

printf("%08x\r\n", ary[0]);
printf("%08x\r\n", ary[1]);
system("pause");

return 0;

```


* 下图:可以看到从0018FF44~0018FF48这个地址的内存原本是0,但由于第一个scanf输入的值是1，所以覆盖成01 00 00 00因为后面的数本身就初始化为0了，所以暂时没看出有什么问题

![Img](https://rtyu-1317440738.cos.ap-guangzhou.myqcloud.com/202305091943601.webp)


* 在第二个scanf中再输入2,又被覆盖成01 00 02 00，但是有一个问题出现了可以看到0018FF48~0018FF49这个地址后面的值本来是88 FF 现在被覆盖成00 00了。这里的数据是函数运行所需要的必要数据，该函数由于函数运行的必要数据被覆盖了，所以它将会在main函数返回的时候会影响到main函数，紧接着该程序就会崩了

![Img](https://rtyu-1317440738.cos.ap-guangzhou.myqcloud.com/202305091943092.webp)

 

 ## long int(失效的状态)
* (short int 是整形减半)(long int 是整形翻倍) 整形翻倍就是4字节翻倍成8字节
 
 * 在微软/C语言开发环境下(long int 关键字是无效的，实际上只占了4字节，并没有像C语言标准那样占8字节)

* 也就是说微软没按标准实施long int关键字

 1.在微软下它做了一个<span style="color: rgb(255, 76, 0);">_int64</span>,这才是long int 

* 下面表示是一个long int 类型的常量。！！！注意如果不在末尾加L就表示的是int 类型的常量，int类型的常量太大了就会装不下，也就是会溢出
 
![Img](https://rtyu-1317440738.cos.ap-guangzhou.myqcloud.com/202305091944134.webp)



想要能输入64位的整形也就是8字节的整形就要输入`` scanf("%I64", &x);``这里如果输i会没反应要输I ,才可以成功的输入8字节的数据 




## scanf 的修饰
案例：
```C
char szBuf[20] = {0};
printf("%08x\r\n", szBuf); #(显示首地址)
scanf("%s", szBuf);
printf(azBuf);

return 0;
}
```
* szBuf是以0结尾字符串的意思， 


![Img](https://rtyu-1317440738.cos.ap-guangzhou.myqcloud.com/202305091944582.webp)


在程序中输入Hello World 然后在内存中只看到hello进来了，而world没进来。

![Img](https://rtyu-1317440738.cos.ap-guangzhou.myqcloud.com/202305091945195.webp)

原因是``scanf在%s``遇到空格或回车是被截断符截断了。因此可以在%s前面加一些修饰如：`` scanf("%[0-9]s", szBuf);`` 得到

![Img](https://rtyu-1317440738.cos.ap-guangzhou.myqcloud.com/202305091945843.webp)

 
 从上面这图可以看到除了0-9以外的所有字符没有被存进内存中，由此可以推出以下规律：
 * `` scanf("%[a-z]s",szBUf);`` 表示我输入合法字母只包含小写子母a到z
 * `` scanf("%[4,5,6]s",szBuf); `` 表示只含4，5，6
 * `` scanf("%[0-9,a-z,A-Z]s",szuBf);`` 这里支持混合，包含除回车、空格、符号以外的所有字符。
 * `` scanf("%[^a-z]",str1);`` ^ 是反条件的意思，什么都可以输入就是a-z不允许，不包括的意思。
 * `` scanf("%19s",szBUf);`` 19表示截断前最多只能接受19个字符，这种方法可以控制scanf 的输入字数限制，可以防止溢出。如果输入的是20就会被"\0" 覆盖了。
 
！！！：中括号里的限制方法叫正则表达式，想了解更多直接百度scanf正则表达式

**整形转字符串**：(取出每一位加上ASCII 字符0，还需检查范围)

例如：325 取出3加上ASCIL 字符0.再把后面两个数以此类推都加上字符0，因为ASCII 0-9是顺着排的 ，最后再补一个"\0"。



**进制转换** ：
```C
// 10 -1 -2 -3
// 12.6 2 5
// 1100.1 


//101.011(2进制)
// 1*2^2 + 0*2^1 + 1*2^0 + 0*2^-1 + 1*2^-2 + 1*2^-3
// 4 + 1 + 0.25 + 0.125
// 5.375


// 3e7.7e (16进制)
// 3*16^2 + 14*16^1 + 7*16^-1 + 7*16^-1 + 14*16^-2

```




